def min_fuel_path(grid):
    N = len(grid)    # 행의 개수
    M = len(grid[0]) # 열의 개수

    # dp[i][j][k] -> (i, j)로 이동할 때 k 방향에서 오는 최소 소모량을 저장하는 테이블
    # k = 0 -> 왼쪽 아래로 이동해 온 경우
    # k = 1 -> 아래로 이동해 온 경우
    # k = 2 -> 오른쪽 아래로 이동해 온 경우

    # dp 배열을 초기화하는데, 각 위치에 대한 최소값을 추적하기 위해
    # 3개의 방향 (왼쪽 아래, 아래, 오른쪽 아래)로 오는 최소값을 'inf'(무한대)로 설정
    # dp[i][j][k]에서 i는 행, j는 열, k는 방향을 의미

    # 3D 동적 프로그래밍 테이블을 생성하는 코드
    dp = [[[float('inf')] * 3 for _ in range(M)] for _ in range(N)]

    # 첫 번째 행의 초기값 설정
    # 첫 번째 행에서는 이동 시작점이므로 셀 자체의 값(grid[0][j])이 바로 최소값
    for j in range(M):
        dp[0][j][0] = grid[0][j] # 왼쪽 아래로 이동해 오는 경우의 초기값 설정
        dp[0][j][1] = grid[0][j] # 바로 아래로 이동해 오는 경우의 초기값 설정
        dp[0][j][2] = grid[0][j] # 오른쪽 아래로 이동해 오는 경우의 초기값 설정

    # 각 행을 차례대로 계산
    for i in range(1, N):
        for j in range(M):
            # 왼쪽 아래로 이동해 오는 경우 (j > 0일 때만 가능)
            if j > 0:
                dp[i][j][0] = min(dp[i][j][0], dp[i-1][j-1][1], dp[i-1][j-1][2]) + grid[i][j]
                # 왼쪽 아래로 이동해 오려면 이전 행의 (i-1, j-1) 위치에서 올 수 있는데,
                # 이전에 아래에서 왔거나(1) 또는 오른쪽 아래에서 왔을 때(2)의 최소값을 비교
                # 그리고 현재 셀의 값(grid[i][j])을 더해줌

            # 바로 아래로 이동해 오는 경우
            dp[i][j][1] = min(dp[i][j][1], dp[i-1][j][0], dp[i-1][j][2]) + grid[i][j]
            # 바로 아래로 이동해 오려면 이전 행의 (i-1, j) 위치에서 올 수 있습니다.
            # 이전에 왼쪽 아래(0)에서 오거나 오른쪽 아래(2)에서 왔을 때의 최소값을 비교하여
            # 현재 셀의 값(grid[i][j])을 더해줌

            # 오른쪽 아래로 이동해 오는 경우 (j < M-1일 때만 가능)
            if j < M-1:
                dp[i][j][2] = min(dp[i][j][2], dp[i-1][j+1][0], dp[i-1][j+1][1]) + grid[i][j]
                # 오른쪽 아래로 이동해 오려면 이전 행의 (i-1, j+1) 위치에서 올 수 있습니다.
                # 이전에 왼쪽 아래(0)에서 오거나 아래에서 왔을 때(1)의 최소값을 비교하여
                # 현재 셀의 값(grid[i][j])을 더해줌

    # 마지막 행에서 최소 비용 찾기
    min_fuel = float('inf')
    
    for j in range(M): # 마지막 행에서 (N-1 번째 행)

        # 마지막 행의 각 열(j)에 대해 3방향 (0: 왼쪽 아래, 1: 아래, 2: 오른쪽 아래)에서 온 값들 중 최소값을 선택
        min_fuel = min(min_fuel, dp[N-1][j][0], dp[N-1][j][1], dp[N-1][j][2])

    return min_fuel


# 지구와 달 사이 거리를 나타내는 N x M 행렬로 나타낼 수 있음. N과 M을 입력 받음.
N, M = map(int, input().split())
if N < 2 or N > 6 or M < 2 or M > 6:
    print("N과 M은 2 이상 6 이하의 자연수여야 합니다.")
    exit()

# N, M (2≤ N, M ≤ 6) / 각 행렬의 원소값은 100 이하의 자연수
# 각 원소 값은 소요되는 기름 양
# 행렬 (기름 소모량)을 입력받음
universe = []

for i in range(N):
    row = list(map(int, input().split()))
    
    # 각 행렬의 원소가 100 이하의 자연수인지 확인
    if any(val > 100 for val in row):
        print("각 행렬의 원소 값은 100 이하의 자연수여야 합니다.")
        exit()

    universe.append(row)

# 전에 움직인 방향으로 똑같이 갈 수 없다. 왼쪽 아래로 왔다면 이번에도 연속으로 왼쪽 아래로 갈 수 없다.
# 소요되는 기름의 양을 최소화하여 가는 방법 찾기
# 최소 기름 소모 경로 찾기
result = min_fuel_path(universe)
print(result)